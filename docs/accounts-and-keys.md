# Accounts, Keys and Signing

Flow introduces new features to give applications and end users more safety and flexibility when managing keys, accounts and the assets inside them.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Accounts](#accounts)
  - [Account creation](#account-creation)
- [Keys](#keys)
  - [Adding a key to an account](#adding-a-key-to-an-account)
  - [Supported signature & hashing algorithms](#supported-signature--hashing-algorithms)
  - [Weighted keys](#weighted-keys)
- [Signing a transaction](#signing-a-transaction)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Accounts

An account on Flow is a record in the chainstate that holds the following information:

- **Address** - unique identifier for the account
- **Balance** - default token balance
- **Public Keys** - public keys authorized on the account
- **Code** - Cadence contracts deployed to the account
- **Storage** - area of the account used to store resource assets

### Account creation

Unlike Ethereum and Bitcoin, Flow does not use cryptographic public keys to derive account addresses. Instead, accounts have unique IDs that are deterministically generated by the network.

This allows for multiple public keys to be associated with one account, or for a single public key to be used across several accounts.

Users must submit an _account creation transaction_ to create a new account. These transactions behave like any other transaction, and therefore must have a payer.

> Who will pay to create my account?

Account creation fees are relatively low, and we expect that wallet providers and exchanges will cover the cost when a user converts fiat to crypto for the first time.

_Conceptually, this isn't much different than Ethereum or Bitcoin. Although private keys can "reserve" account addresses off-chain, new accounts aren't visible to the network until somebody submits (and pays for) a transaction to that address._

> What does an account creation transaction look like?

Here's an example of how to submit an account creation transaction with the Go SDK: [Account Creation Example](https://github.com/dapperlabs/flow-go-sdk/blob/master/examples/emulator/create_account/main.go).

> What about smart contracts?

Ethereum draws a distinction between accounts and contracts, both of which are addressable. Ethereum contracts are immutable and cannot be upgraded after deployment.

To achieve the same in Flow, simply create an account with deployed code and an empty list of authorized keys. This renders the account immutable by making it impossible to authorize a transaction that would mutate the account code.

### Account addresses

_Documentation coming soon..._

## Keys

Flow accounts can be configured with multiple public keys that are used to control access. Owners of the associated private keys can sign transactions to mutate the account's state.

### Adding a key to an account

When adding a public key to an account, you must specify the following information:

- Index (used to identify key within an account)
- Raw public key (encoded as bytes)
- Signature algorthim (see codes below)
- Hashing algorithm (see codes below)
- Weight (integer between 1-1000)

The signature and hashing algorthims are included because Flow supports a variety of algorithms and curves.

> How are keys added to an account?

To add keys to an account, you can submit a transaction that is authorized to access that account.

Here's an example of how to add an account key with the Go SDK: [Add Account Key Example](https://github.com/dapperlabs/flow-go-sdk/blob/master/examples/emulator/add_account_key/main.go).

### Supported signature & hashing algorithms

Flow will have initial support for a predefined set of signature and hash pairings, but more curves and algorithms will be added in the future.

**Signature Algorithms** 

| Algorithm    | Curve     | ID              | Code |
|--------------|-----------|-----------------|------|
| ECDSA        | P-256     | ECDSA_P256      | 2    |
| ECDSA        | SECp256k1 | ECDSA_SECp256k1 | 3    |

**Hashing Algorithms**

| Algorithm    | Size      | ID              | Code |
|--------------|-----------|-----------------|------|
| SHA-2        | 256       | SHA2_256        | 1    |
| SHA-2        | 384       | SHA2_384        | 2    |
| SHA-3        | 256       | SHA3_256        | 3    |
| SHA-4        | 384       | SHA3_384        | 4    |

**Compatibility Table**

|                 | SHA2_256 | SHA2_384 | SHA3_256 | SHA3_384 |
|-----------------|----------|----------|----------|----------|
| ECDSA_P256      | ✅       | ✅       | ✅       | ✅       |
| ECDSA_SECp256k1 | ✅       | ✅       | ✅       | ✅       |

### Weighted keys

Each account key has a weight that determines the signing power it holds. A transaction is not authorized to access an account unless it has a total signature weight greater than or equal to `1000`, the weight threshold.

For example, an account might contain the following keys:

- Key Index: 1, Weight: 500
- Key Index: 2, Weight: 500
- Key Index: 3, Weight: 500

This represents a 2-of-3 multisig quorum, in which a transaction is authorized to access the account if it receives signatures from _at least_ 2 out of 3 keys.

## Signing a transaction

Signing a transaction for Flow is a multi-step process that can involve one or more accounts, each of which signs for a different purpose.

### Signer roles

- *Proposer:* the account that is proposing the transaction.
- *Payer:* the account paying for the network and gas fees.
- *Authorizers:* zero or more accounts authorizing the transaction to mutate their state.

### Signer declarations

A transaction must pre-declare the accounts that will be signing for each of the above roles. Signer declarations are included in the transaction body, which is signed by all parties.

```
TransactionBody {
  ...
  proposer    SignerDeclaration
  payer       SignerDeclaration
  authorizers List<SignerDeclaration>
}
```

A signer declaration includes the following:

```
SignerDeclaration {
  address Address
  keys    List<AccountKey>
}

AccountKey {
  index           Integer
  sequence_number Optional<Integer>
}
```

Each declaration specifies the address of a signer account and the list of keys that must be used for signing. A account key is identified by its unique index within the account.

### Sequence numbers

Flow uses sequence numbers to prevent [transaction replay attacks](https://en.wikipedia.org/wiki/Replay_attack).

Sequence numbers work similarly to transaction nonces in Ethereum, but with several key differences:

- Sequence numbers are **incremented per account key**, not per account
- When creating a transaction, only the **proposer must specify a sequence number**. Payers and authorizers are not required to.

Furthermore, the transaction proposer is only required to specify a sequence number for one of the keys in its signer declaration. This key is referred to as the _proposal key_.

Each time an account key is used as a proposal key, its sequence number increases by 1 (assuming the transaction is executed).

A transaction is rejected if its proposal key does not specify a sequence number equal to the sequence number stored on the account _at execution time._

**Example**

After the below tranaction is executed, the sequence number for `Key 0` on `Account 0x01` will increase to 43.

```json
{
  // other transaction fields
  ...
  "signers": [
    {
      "address": "0x01",
      "roles": ["proposer", "authorizer"],
      "keys": [
        { "index": 0, "sequence_number": 42 }, // proposal key
        { "index": 1 }
      ]
    },
    {
      "address": "0x02",
      "roles": ["payer"],
      "keys": [{ "index": 2 }]
    },
    {
      "address": "0x03",
      "roles": ["authorizer"],
      "keys": [{ "index": 6 }]
    }
  ]
}
```

### Transaction signatures

_Documentation coming soon..._
