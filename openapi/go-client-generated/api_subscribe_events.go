
/*
 * Access API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SubscribeEventsApiService service
/*
SubscribeEventsApiService Subscribe events
IMPORTANT NOTE: This is a WebSocket connection, so the &#x60;ws://&#x60; or &#x60;wss://&#x60; schema should be used to subscribe to this endpoint.  This endpoint streams on-chain events for all blocks starting at the requested start block, up until the latest available block. Once the latest block is reached, the stream will remain open, and responses will be sent for each new block as it becomes available. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SubscribeEventsApiSubscribeEventsGetOpts - Optional Parameters:
     * @param "StartHeight" (optional.Interface of BlockHeight) -  The block height of the events being streamed. Either provide this parameter or &#x60;start_block_id&#x60; parameter. This parameter is incompatible with &#x60;start_block_id&#x60; parameter.
     * @param "StartBlockId" (optional.Interface of string) -  The block id of the events being streamed. Either provide this parameter or &#x60;start_height&#x60; parameter. This parameter is incompatible with &#x60;start_height&#x60; parameter.
     * @param "HeartbeatInterval" (optional.String) -  Interval in block heights at which the server should return a heartbeat message to the client.
     * @param "EventTypes" (optional.Interface of []string) -  A comma-separated list of events type to include.
     * @param "Addresses" (optional.Interface of []string) -  A comma-separated list of addresses who&#x27;s events should be included.
     * @param "Contracts" (optional.Interface of []string) -  A comma-separated list of contracts who&#x27;s events should be included.
@return SubscribeEvents
*/

type SubscribeEventsApiSubscribeEventsGetOpts struct {
    StartHeight optional.Interface
    StartBlockId optional.Interface
    HeartbeatInterval optional.String
    EventTypes optional.Interface
    Addresses optional.Interface
    Contracts optional.Interface
}

func (a *SubscribeEventsApiService) SubscribeEventsGet(ctx context.Context, localVarOptionals *SubscribeEventsApiSubscribeEventsGetOpts) (SubscribeEvents, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SubscribeEvents
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribe_events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.StartHeight.IsSet() {
		localVarQueryParams.Add("start_height", parameterToString(localVarOptionals.StartHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartBlockId.IsSet() {
		localVarQueryParams.Add("start_block_id", parameterToString(localVarOptionals.StartBlockId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HeartbeatInterval.IsSet() {
		localVarQueryParams.Add("heartbeat_interval", parameterToString(localVarOptionals.HeartbeatInterval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventTypes.IsSet() {
		localVarQueryParams.Add("event_types", parameterToString(localVarOptionals.EventTypes.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Addresses.IsSet() {
		localVarQueryParams.Add("addresses", parameterToString(localVarOptionals.Addresses.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Contracts.IsSet() {
		localVarQueryParams.Add("contracts", parameterToString(localVarOptionals.Contracts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SubscribeEvents
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 408 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 503 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
